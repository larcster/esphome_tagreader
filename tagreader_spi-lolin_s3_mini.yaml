wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: ${name}
    password: !secret fallback_password

captive_portal:

improv_serial:

substitutions:
  name: tagreader
  friendly_name: TagReader
esp32:
 variant: esp32s3
 board: lolin_s3_mini
 framework:
   type: esp-idf

esphome:
  name: $name
  name_add_mac_suffix: true
  project:
    name: Bergtveit.Tagreader
    version: dev
  on_boot:
    priority: -10
    then:
      - wait_until:
          api.connected:
      - logger.log: API is connected!
      - light.turn_on:
          id: activity_led
          brightness: 100%
          red: 0%
          green: 0%
          blue: 100%
          flash_length: 500ms
   
button:
  - platform: restart
    name: "Restart"
    icon: mdi:power-cycle
    entity_category: config

logger:
#  level: VERY_VERBOSE
api:
  services:
  - service: write_music_tag
    variables:
      music_url: string
      music_info: string
    then:
    - light.turn_on:
        id: activity_led
        brightness: 100%
        red: 100%
        green: 0%
        blue: 0%
    - lambda: |-
        auto message = new nfc::NdefMessage();
        std::string uri = "";
        std::string text = "";
        uri += music_url;
        text += music_info;

        // Strip ? and everything after
        size_t pos = uri.find('?');
        if (pos != std::string::npos) {
          uri = uri.substr(0, pos);
        }
    
        if ( uri != "" ) {
          message->add_uri_record(uri);
        }
        if ( text != "" ) {
          message->add_text_record(text);
        }
        id(pn532_board).write_mode(message);
    - wait_until:
        not:
          pn532.is_writing:
    - light.turn_off:
        id: activity_led

  - service: write_printing_tag
    variables:
      filename: string
      file_info: string
    then:
    - light.turn_on:
        id: activity_led
        brightness: 100%
        red: 100%
        green: 0%
        blue: 0%
    - lambda: |-
        auto message = new nfc::NdefMessage();
        std::string uri = "file://";
        std::string text = "";
        uri += filename;
        text += file_info;
        if ( filename != "" ) {
          message->add_uri_record(uri);
        }
        if ( file_info != "" ) {
          message->add_text_record(text);
        }
        id(pn532_board).write_mode(message);
    - wait_until:
        not:
          pn532.is_writing:
    - light.turn_off:
        id: activity_led

  - service: write_color_tag
    variables:
      color_code: string
      color_name: string
    then:
    - light.turn_on:
        id: activity_led
        brightness: 100%
        red: 100%
        green: 0%
        blue: 0%
    - lambda: |-
        auto message = new nfc::NdefMessage();
        std::string uri = "color://";
        std::string text = "";
        uri += color_code;
        text += color_name;
        if ( color_code != "" ) {
          message->add_uri_record(uri);
        }
        if ( text != "" ) {
          message->add_text_record(text);
        }
        id(pn532_board).write_mode(message);
        ESP_LOGI("tagwriter", "Writing color tag: %s (%s)", uri.c_str(), text.c_str());
        id(pn532_board).write_mode(message);
    - wait_until:
        not:
          pn532.is_writing:
    - light.turn_off:
        id: activity_led
ota:
  - platform: esphome

spi:
  clk_pin: GPIO12
  miso_pin: GPIO13
  mosi_pin: GPIO11
  
globals:
  - id: source
    type: std::string
  - id: url
    type: std::string
  - id: info
    type: std::string
  - id: lambda_result    # Used for more simple post-processing code block
    type: std::string
  - id: read_success
    type: bool
    restore_value: no
    initial_value: 'false'
    # Rate limiting functionality
  - id: last_scan_time
    type: unsigned long
    restore_value: no
    initial_value: '0'
  - id: rate_limit_ms
    type: unsigned long
    restore_value: no
    initial_value: '2000'

pn532_spi:
  cs_pin: GPIO5
  id: pn532_board
  data_rate: 200kHz
  update_interval: 200ms
  on_tag:
    then:
    #- delay: 0.15s #to fix slow component
    - binary_sensor.template.publish:
        id: tag_present
        state: true
    - lambda: |-
        unsigned long now = millis();
        id(lambda_result)="none";
        if (now - id(last_scan_time) < id(rate_limit_ms)) {
          ESP_LOGI("nfc", "Scan ignored (cooldown active)");
          id(lambda_result)="rate_limited";
          return;  // ignore this scan
        }
        id(read_success) = false;
        id(source)="uid";
        id(url)="";
        id(info)="";
        if (tag.has_ndef_message()) {
          auto message = tag.get_ndef_message();
          auto records = message->get_records();
          const char *applemusic_prefix="https://music.apple.com";
          const char *spotify_prefix="https://open.spotify.com";
          const char *sonos_prefix="sonos-2://";
          const char *printfile_prefix="file://";
          const char *colortag_prefix="color://";
          for (auto &record : records) { // iterate through payload elements and determine type of message
            auto &payload = record->get_payload();
            auto &type = record->get_type();
            if (type == "U"){ // URI record, determine what type based on content
              id(url)=payload;
              id(read_success) = true; // since an URI record was found, set read_success to TRUE
              id(last_scan_time) = now;  // record new scan time
              if (payload.compare(0, strlen(applemusic_prefix), applemusic_prefix)==0){
                ESP_LOGD("tagreader", "Found Apple Music tag NDEF");
                id(source)="amusic";
                id(lambda_result)="music_tag";
              }
              else if (payload.compare(0, strlen(spotify_prefix), spotify_prefix)==0){
                ESP_LOGD("tagreader", "Found Spotify tag NDEF");
                id(source)="spotify";
                id(lambda_result)="music_tag";
              }
              else if (payload.compare(0, strlen(sonos_prefix), sonos_prefix)==0){
                ESP_LOGD("tagreader", "Found Sonos app tag NDEF");
                id(source)="sonos";
                id(lambda_result)="music_tag";
              }
              else if (payload.compare(0, strlen(printfile_prefix), printfile_prefix)==0){
                ESP_LOGD("tagreader", "Found print tag NDEF");
                id(source)="file";
                id(lambda_result)="print_tag";
              }
              else if (payload.compare(0, strlen(colortag_prefix), colortag_prefix)==0){
                ESP_LOGD("tagreader", "Found color tag NDEF");
                id(source)="color";
                id(lambda_result)="color_tag";
                }
            }
            else if (type == "T" ) { // Text record, set as info
              ESP_LOGD("tagreader", "Found info tag NDEF");
              id(info)=payload;
            }
          }
        }
        else {
          id(source)="error";
          id(lambda_result)="none";
        }
    - if: # Handle LED action here: If rate limited, do nothing. Else, if read sucess, flash green. Else (read failure), flash red
        condition:
          lambda: 'return (id(lambda_result)!="rate_limited");'
        then:
        - if:
            condition:
              lambda: 'return id(read_success);'
            then:
            - light.turn_on:
                id: activity_led
                brightness: 100%
                red: 0%
                green: 100%
                blue: 0%
                flash_length: 500ms
            else:
            - light.turn_on:
                id: activity_led
                brightness: 100%
                red: 100%
                green: 0%
                blue: 0%
                flash_length: 500ms
        
    - if: # Lambda result = music tag
        condition:
          lambda: 'return (id(lambda_result)=="music_tag");'
        then:
        - homeassistant.event:
            event: esphome.music_tag
            data:
              reader: !lambda |-
                return App.get_name().c_str();
              source: !lambda |-
                return id(source);
              url: !lambda |-
                return id(url);
              info: !lambda |-
                return id(info);

    - if: # Lambda result = printing tag
        condition:
          lambda: 'return (id(lambda_result)=="printing_tag");'
        then:
        - homeassistant.event:
            event: esphome.print_tag
            data:
              reader: !lambda |-
                return App.get_name().c_str();
              source: !lambda |-
                return id(source);
              url: !lambda |-
                return id(url).erase(0,7); // erasing 'file://'
              info: !lambda |-
                return id(info);

    - if: # Lambda result = color tag
        condition:
          lambda: 'return (id(lambda_result)=="color_tag");'
        then:
        - homeassistant.event:
            event: esphome.color_tag
            data:
              reader: !lambda |-
                return App.get_name().c_str();
              source: !lambda |-
                return id(source);
              url: !lambda |-
                return id(url).erase(0,8); // erasing 'color://'
              info: !lambda |-
                return id(info);
               
  on_tag_removed:
    then:
    - binary_sensor.template.publish:
        id: tag_present
        state: false
    - homeassistant.event:
        event: esphome.tag_removed

binary_sensor:
  - platform: status
    name: "Status"
    entity_category: diagnostic
  - platform: template
    name: "Tag Present"
    id: tag_present
    device_class: occupancy
    icon: mdi:nfc

text_sensor:
  - platform: version
    hide_timestamp: true
    name: "ESPHome Version"
    entity_category: diagnostic
  - platform: wifi_info
    ip_address:
      name: "IP Address"
      icon: mdi:wifi
      entity_category: diagnostic
    ssid:
      name: "Connected SSID"
      icon: mdi:wifi-strength-2
      entity_category: diagnostic

light:
  - platform: esp32_rmt_led_strip
    chipset: ws2812
    pin: GPIO2
    num_leds: 1
    flash_transition_length: 200ms
    rgb_order: GRB
    id: activity_led
    name: "LED"
    restore_mode: ALWAYS_OFF
