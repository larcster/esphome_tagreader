wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: ${name}
    password: !secret fallback_password

captive_portal:

improv_serial:

substitutions:
  name: tagreader
  friendly_name: TagReader
esp32:
 variant: esp32s3
 board: lolin_s3_mini
 framework:
   type: esp-idf

esphome:
  name: $name
  name_add_mac_suffix: true
  project:
    name: Bergtveit.Tagreader
    version: dev
  on_boot:
    priority: -10
    then:
      - wait_until:
          api.connected:
      - logger.log: API is connected!
      - light.turn_on:
          id: activity_led
          brightness: 100%
          red: 0%
          green: 0%
          blue: 100%
          flash_length: 500ms
      - switch.turn_on: led_enabled

switch:
  - platform: template
    name: "${friendly_name} LED Enabled"
    id: led_enabled
    icon: mdi:alarm-light-outline
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    entity_category: config

button:
  - platform: template
    name: Cancel writing
    id: cancel_writing
    icon: mdi:pencil-off
    on_press:
      then:
        - lambda: 'id(pn532_board).read_mode();'
        - light.turn_off:
            id: activity_led

  - platform: restart
    name: "${friendly_name} Restart"
    entity_category: config

logger:
#  level: VERY_VERBOSE
api:
  services:
  - service: write_music_tag
    variables:
      music_url: string
      music_info: string
    then:
    - light.turn_on:
        id: activity_led
        brightness: 100%
        red: 100%
        green: 0%
        blue: 0%
    - lambda: |-
        auto message = new nfc::NdefMessage();
        std::string uri = "";
        std::string text = "";
        uri += music_url;
        text += music_info;

        // Strip ? and everything after
        size_t pos = uri.find('?');
        if (pos != std::string::npos) {
          uri = uri.substr(0, pos);
        }
    
        if ( uri != "" ) {
          message->add_uri_record(uri);
        }
        if ( text != "" ) {
          message->add_text_record(text);
        }
        id(pn532_board).write_mode(message);
    - wait_until:
        not:
          pn532.is_writing:
    - light.turn_off:
        id: activity_led

  - service: write_printing_tag
    variables:
      filename: string
      file_info: string
    then:
    - light.turn_on:
        id: activity_led
        brightness: 100%
        red: 100%
        green: 0%
        blue: 0%
    - lambda: |-
        auto message = new nfc::NdefMessage();
        std::string uri = "file://";
        std::string text = "";
        uri += filename;
        text += file_info;
        if ( filename != "" ) {
          message->add_uri_record(uri);
        }
        if ( file_info != "" ) {
          message->add_text_record(text);
        }
        id(pn532_board).write_mode(message);
    - wait_until:
        not:
          pn532.is_writing:
    - light.turn_off:
        id: activity_led

  - service: write_color_tag
    variables:
      color_code: string
      color_name: string
    then:
    - light.turn_on:
        id: activity_led
        brightness: 100%
        red: 100%
        green: 0%
        blue: 0%
    - lambda: |-
        auto message = new nfc::NdefMessage();
        std::string uri = "color://";
        std::string text = "";
        uri += color_code;
        text += color_name;
        if ( color_code != "" ) {
          message->add_uri_record(uri);
        }
        if ( text != "" ) {
          message->add_text_record(text);
        }
        id(pn532_board).write_mode(message);
        ESP_LOGI("tagwriter", "Writing color tag: %s (%s)", uri.c_str(), text.c_str());
        id(pn532_board).write_mode(message);
    - wait_until:
        not:
          pn532.is_writing:
    - light.turn_off:
        id: activity_led
ota:
  - platform: esphome

spi:
  clk_pin: GPIO12
  miso_pin: GPIO13
  mosi_pin: GPIO11
  
globals:
  - id: source
    type: std::string
  - id: url
    type: std::string
  - id: info
    type: std::string
  - id: read_success
    type: bool
    restore_value: no
    initial_value: 'false'

pn532_spi:
  cs_pin: GPIO5
  id: pn532_board
  data_rate: 200kHz
  update_interval: 200ms
  on_tag:
    then:
    #- delay: 0.15s #to fix slow component
    - binary_sensor.template.publish:
        id: tag_present
        state: true
    - lambda: |-
        id(read_success) = false;
        id(source)="uid";
        id(url)="";
        id(info)="";
        if (tag.has_ndef_message()) {
          auto message = tag.get_ndef_message();
          auto records = message->get_records();
          const char *applemusic_prefix="https://music.apple.com";
          const char *spotify_prefix="https://open.spotify.com";
          const char *sonos_prefix="sonos-2://";
          const char *printfile_prefix="file://";
          const char *colortag_prefix="color://";
          for (auto &record : records) {
            auto &payload = record->get_payload();
            auto &type = record->get_type();

            if (type == "U"){
              id(url)=payload;
              id(read_success) = true;
              if (payload.compare(0, strlen(applemusic_prefix), applemusic_prefix)==0){
                ESP_LOGD("tagreader", "Found Apple Music tag NDEF");
                id(source)="amusic";
              }
              else if (payload.compare(0, strlen(spotify_prefix), spotify_prefix)==0){
                ESP_LOGD("tagreader", "Found Spotify tag NDEF");
                id(source)="spotify";
              }
              else if (payload.compare(0, strlen(sonos_prefix), sonos_prefix)==0){
                ESP_LOGD("tagreader", "Found Sonos app tag NDEF");
                id(source)="sonos";
              }
              else if (payload.compare(0, strlen(printfile_prefix), printfile_prefix)==0){
                ESP_LOGD("tagreader", "Found print tag NDEF");
                id(source)="file";
              }
              else if (payload.compare(0, strlen(colortag_prefix), colortag_prefix)==0){
                ESP_LOGD("tagreader", "Found color tag NDEF");
                id(source)="color";
                }
            }
            else if (type == "T" ) {
              ESP_LOGD("tagreader", "Found info tag NDEF");
              id(info)=payload;
            }
          }
        }
        else {
          id(source)="error";
        }
    - if:
        condition:
          lambda: 'return id(read_success);'
        then:
        - light.turn_on:
            id: activity_led
            brightness: 100%
            red: 0%
            green: 100%
            blue: 0%
            flash_length: 500ms
        else:
        - light.turn_on:
            id: activity_led
            brightness: 100%
            red: 100%
            green: 0%
            blue: 0%
            flash_length: 500ms
    - if:
        condition:
          lambda: 'return ( id(source)=="uid");'
        then:
          - homeassistant.tag_scanned: !lambda |-
              ESP_LOGD("tagreader", "No HA NDEF, using UID");
              return x;
        else:
        - if:
            condition:
              lambda: 'return ( id(source)=="error" );'
            then:
            - homeassistant.event:
                event: esphome.tag_read_error
                data:
                  reader: !lambda |-
                    return App.get_name().c_str();
                  info: !lambda |-
                    return id(info);
            else:
            - if:
                condition:
                  lambda: 'return ( id(source)=="file" );'
                then:
                - homeassistant.event:
                    event: esphome.print_tag
                    data:
                      reader: !lambda |-
                        return App.get_name().c_str();
                      source: !lambda |-
                        return id(source);
                      url: !lambda |-
                        return id(url).erase(0,7); // erasing 'file://'
                      info: !lambda |-
                        return id(info);
                else:
                - if:
                    condition:
                        lambda: 'return ( id(source)=="color" );'
                    then:
                    - homeassistant.event:
                        event: esphome.color_tag
                        data:
                          reader: !lambda |-
                            return App.get_name().c_str();
                          source: !lambda |-
                            return id(source);
                          url: !lambda |-
                            return id(url).erase(0,8); // erasing 'color://'
                          info: !lambda |-
                            return id(info);
                    else:
                        - homeassistant.event:
                            event: esphome.music_tag
                            data:
                              reader: !lambda |-
                                return App.get_name().c_str();
                              source: !lambda |-
                                return id(source);
                              url: !lambda |-
                                return id(url);
                              info: !lambda |-
                                return id(info);
    # Turn off LED after short delay
    - delay: 1s
    - light.turn_off:
        id: activity_led
        transition_length: 0ms
  on_tag_removed:
    then:
    - binary_sensor.template.publish:
        id: tag_present
        state: false
    - homeassistant.event:
        event: esphome.tag_removed

binary_sensor:
  - platform: status
    name: "${friendly_name} Status"
    entity_category: diagnostic
  - platform: template
    name: "Tag Present"
    id: tag_present
    device_class: occupancy
    icon: mdi:nfc

text_sensor:
  - platform: version
    hide_timestamp: true
    name: "${friendly_name} ESPHome Version"
    entity_category: diagnostic
  - platform: wifi_info
    ip_address:
      name: "${friendly_name} IP Address"
      icon: mdi:wifi
      entity_category: diagnostic
    ssid:
      name: "${friendly_name} Connected SSID"
      icon: mdi:wifi-strength-2
      entity_category: diagnostic

light:
  - platform: esp32_rmt_led_strip
    chipset: ws2812
    pin: GPIO2
    num_leds: 1
    flash_transition_length: 200ms
    rgb_order: GRB
    id: activity_led
    name: "${friendly_name} LED"
    restore_mode: ALWAYS_OFF
